# A0144885R
###### \java\seedu\address\commons\events\storage\StorageFileChangeEvent.java
``` java
package seedu.address.commons.events.storage;

import seedu.address.commons.events.BaseEvent;

/**
 * Indicates an event when the storage file is changed
 */
public class StorageFileChangeEvent extends BaseEvent {

    public String filePath;

    public StorageFileChangeEvent(String filePath) {
        this.filePath = filePath;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }
}
```
###### \java\seedu\address\commons\events\ui\ChangeViewRequestEvent.java
``` java
package seedu.address.commons.events.ui;

import java.util.List;

import seedu.address.commons.events.BaseEvent;

/**
 * Indicates a request to change current view
 */
public class ChangeViewRequestEvent extends BaseEvent {

    public final List<String> viewGroups;

    public ChangeViewRequestEvent(List<String> viewGroups) {
        this.viewGroups = viewGroups;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### \java\seedu\address\commons\events\ui\ShowTaskGroupEvent.java
``` java
package seedu.address.commons.events.ui;

import seedu.address.commons.events.BaseEvent;

/**
 * Indicates a request to show one task group and hide the current ons.
 */
public class ShowTaskGroupEvent extends BaseEvent {

    public final String title;

    public ShowTaskGroupEvent(String title) {
        this.title = title;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### \java\seedu\address\commons\util\DateUtil.java
``` java
package seedu.address.commons.util;

import seedu.address.model.task.Deadline;
import seedu.address.model.task.date.DateTime;
import seedu.address.model.task.date.DateValue;
import seedu.address.model.task.date.TaskDate;
import seedu.address.model.task.date.TimeUnassigned;

/**
 * Helper functions for handling DateValue.
 */
public class DateUtil {

    /* Number of milliseconds in one day */
    public static final long ONE_DAY_IN_MILLISECONDS = 24 * 3600 * 1000;

    public static final long MONDAY = 1;
    public static final long SUNDAY = 0;

    /**
     * Returns DateValue object with date set to today.
     */
    public static DateValue getToday() {
        return (DateValue) new DateTime();
    }

    /**
     * Returns DateValue object with date set to tomorrow.
     */
    public static DateValue getTomorrow() {
        return getNextDay(getToday());
    }

    /**
     * Returns true if the two pairs of Dates intersecting
     *
     * @param firstBegin beginning Date of the first pair
     * @param firstEnd   ending Date of the first pair
     * @param secondBegin beginning Date of the first pair
     * @param secondEnd  ending Date of the first pair
     */
    public static boolean haveIntersection(DateValue firstBegin, DateValue firstEnd,
                                                DateValue secondBegin, DateValue secondEnd) {
        if (firstBegin.after(secondEnd) || secondBegin.after(firstEnd)) {
            return false;
        } else {
            return true;
        }
    }

    public static boolean isTaskDateMatch(TaskDate d1, TaskDate d2) {
        if (d1 instanceof TimeUnassigned && d2 instanceof TimeUnassigned) {
            return true;
        }
        if (d1 instanceof TimeUnassigned) {
            return false;
        }
        if (d2 instanceof TimeUnassigned) {
            return false;
        }
        return haveIntersection(d1.getBeginning(), d1.getEnding(), d2.getBeginning(), d2.getEnding());
    }

    public static boolean isDeadlineMatch(Deadline d1, Deadline d2) {
        return isTaskDateMatch(d1.date, d2.date);
    }

    /**
     * Return the next day of given date.
     */
    public static DateValue getNextDay(DateValue date) {
        DateValue newDate = new DateTime(date);
        return newDate.setTime(newDate.getTime() + ONE_DAY_IN_MILLISECONDS);
    }

    /**
     * Return the previous day of given date.
     */
    public static DateValue getPreviousDay(DateValue date) {
        DateValue newDate = new DateTime(date);
        return newDate.setTime(newDate.getTime() - ONE_DAY_IN_MILLISECONDS);
    }

    /**
     * Returns the beginning of day at time 00:00:00.
     */
    public static DateValue getBeginOfDay(DateValue date) {
        DateValue newDate = new DateTime(date);
        return newDate.setHours(0).setMinutes(0).setSeconds(0);
    }

    /**
     * Returns the end of day at time 23:59:59.
     */
    public static DateValue getEndOfDay(DateValue date) {
        DateValue newDate = new DateTime(date);
        return newDate.setHours(23).setMinutes(59).setSeconds(59);
    }

}
```
###### \java\seedu\address\commons\util\StringUtil.java
``` java
    /**
     * Trims leading, trailing and continuous spaces in a string
     *
     * @param text cannot be null
     */
    public static String removeRedundantSpaces(String text) {
        assert text != null;
        return text.trim().replace(" +", " ");
    }
```
###### \java\seedu\address\logic\commands\SetStorageCommand.java
``` java
package seedu.address.logic.commands;

import java.io.File;
import java.io.IOException;
import java.nio.file.Paths;

import seedu.address.commons.core.EventsCenter;
import seedu.address.commons.events.storage.StorageFileChangeEvent;
import seedu.address.logic.commands.exceptions.CommandException;

/**
 * Changes storage file.
 *
 * If the provided input is a directory path, default filename (task_manager.xml) will be used.
 */
public class SetStorageCommand extends Command {

    public static final String COMMAND_WORD = "set-storage";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Set prefered storage file path.";

    public static final String MESSAGE_INVALID_FILE = "Invalid file/directory path";
    public static final String MESSAGE_SET_STORAGE_SUCCESS = "Storage file changed to %s";
    public static final String MESSAGE_ERROR_CREATE_FILE = "Invalid file/directory path";

    public static final String DEFAULT_FILENAME = "task_manager.xml";

    public String filePath;

    public SetStorageCommand(String filePath) {
        this.filePath = filePath.trim();
    }

    @Override
    public CommandResult execute() throws CommandException {

        File file = new File(filePath);

        if (!file.exists()) {
            throw new CommandException(MESSAGE_INVALID_FILE);
        }

        if (file.isDirectory()) {
            filePath = Paths.get(filePath, DEFAULT_FILENAME).toString();
            file = new File(filePath);
        }

        if (file.exists()) {
            EventsCenter.getInstance().post(new StorageFileChangeEvent(filePath));
        } else {
            try {
                file.createNewFile();
                EventsCenter.getInstance().post(new StorageFileChangeEvent(filePath));
            } catch (IOException e) {
                throw new CommandException(MESSAGE_ERROR_CREATE_FILE);
            }
        }
        return new CommandResult(String.format(MESSAGE_SET_STORAGE_SUCCESS, filePath));

    }

}
```
###### \java\seedu\address\logic\commands\ViewCommand.java
``` java
package seedu.address.logic.commands;

import java.util.ArrayList;

import seedu.address.commons.core.EventsCenter;

import seedu.address.commons.events.ui.ChangeViewRequestEvent;
import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.logic.commands.exceptions.CommandException;
import seedu.address.model.task.Status;

/**
 * Change the view of UI.
 *
 * View groups can be any value of task status plus 3 additional views:
 *     all, calendar or unfinished.
 */
public class ViewCommand extends Command {

    public static final String COMMAND_WORD = "view";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Change the view of UI."
        + "e.g. view [all|calendar|done|floating|overdue|today|tomorrow|future|unfinished]";

    public static final String MESSAGE_SUCCESS = "View changed to %s";
    public static final String MESSAGE_ERROR = "Invalid input, allowed input: all|calendar|done|"
        + "floating|overdue|today|tomorrow|future";

    public static final String ALL = "All";
    public static final String CALENDAR = "Calendar";
    public static final String UNFINISHED = "Unfinished";
    public static final String EMPTY = "";
    public static final int NOT_FOUND = -1;

    public static final String[] VIEW_GROUPS = {
        Status.DONE, Status.FLOATING, Status.OVERDUE, Status.TODAY, Status.TOMORROW, Status.FUTURE,
        ALL, CALENDAR, UNFINISHED
    };

    public final ArrayList<String> viewGroups;

    /**
     * Creates an AddCommand using raw values.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public ViewCommand(String[] params) throws IllegalValueException {
        this.viewGroups = new ArrayList<String>();
        for (String param : params) {
            if (param.equals(EMPTY)) {
                continue;
            }
            int index = getIndex(param);
            if (index == NOT_FOUND) {
                throw new IllegalValueException(MESSAGE_ERROR);
            }
            this.viewGroups.add(VIEW_GROUPS[index]);
        }
        // Default view has DONE and UNFINISHED
        if (this.viewGroups.isEmpty()) {
            this.viewGroups.add(Status.DONE);
            this.viewGroups.add(UNFINISHED);
        }
    }

    /* Find the index in view_groups */
    int getIndex(String param) {
        int index = 0;
        for (String viewGroup : VIEW_GROUPS) {
            if (param.toLowerCase().equals(viewGroup.toLowerCase())) {
                return index;
            }
            index++;
        }
        return NOT_FOUND;
    }

    @Override
    public CommandResult execute() throws CommandException {
        model.updateFilteredListToShowAll();
        EventsCenter.getInstance().post(new ChangeViewRequestEvent(viewGroups));
        return new CommandResult(String.format(MESSAGE_SUCCESS, String.join("|", viewGroups)));
    }

}
```
###### \java\seedu\address\logic\parser\ViewCommandParser.java
``` java
package seedu.address.logic.parser;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.logic.commands.Command;
import seedu.address.logic.commands.IncorrectCommand;
import seedu.address.logic.commands.ViewCommand;

/**
 * Parses input arguments and creates a new ViewCommand object
 */
public class ViewCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the ViewCommand
     * and returns an ViewCommand object for execution.
     */
    public Command parse(String args) {

        try {
            return new ViewCommand(args.split("\\s+"));
        } catch (IllegalValueException e) {
            return new IncorrectCommand(e.getMessage());
        }
    }

}
```
###### \java\seedu\address\MainApp.java
``` java
    public void reload() {
        ui.stop();
        EventsCenter.clearSubscribers();

        storage = new StorageManager(config.getTaskManagerFilePath(), config.getUserPrefsFilePath());
        model = initModelManager(storage, userPrefs);
        logic = new LogicManager(model, storage);
        ui = new UiManager(logic, config, userPrefs);

        initEventsCenter();

        ui.start(new Stage());
    }
```
###### \java\seedu\address\MainApp.java
``` java
    @Subscribe
    public void handleStorageFileChangeEvent(StorageFileChangeEvent event) {
        logger.info("============================ [ Restarting Address Book ] =============================");

        config.setTaskManagerFilePath(event.filePath);
        saveConfig();
        reload();
    }
```
###### \java\seedu\address\model\ModelManager.java
``` java
package seedu.address.model;

import java.util.ArrayList;
import java.util.Set;
import java.util.logging.Logger;

import javafx.collections.ObservableList;
import javafx.collections.transformation.FilteredList;
import seedu.address.commons.core.ComponentManager;
import seedu.address.commons.core.LogsCenter;
import seedu.address.commons.core.UnmodifiableObservableList;
import seedu.address.commons.events.model.TaskManagerChangedEvent;
import seedu.address.commons.util.CollectionUtil;
import seedu.address.commons.util.DateUtil;
import seedu.address.commons.util.StringUtil;
import seedu.address.model.task.Deadline;
import seedu.address.model.task.ReadOnlyTask;
import seedu.address.model.task.Task;
import seedu.address.model.task.TaskList.TaskNotFoundException;

/**
 * Represents the in-memory model of the address book data.
 * All changes to any model should be synchronized.
 */
public class ModelManager extends ComponentManager implements Model {
    private static final Logger logger = LogsCenter.getLogger(ModelManager.class);

    private final TaskManager taskManager;
    private FilteredList<ReadOnlyTask> filteredTasks;
    private TaskManager taskManagerCopy;
    private String flag;

    /**
     * Initializes a ModelManager with the given taskManager and userPrefs.
     */
    public ModelManager(ReadOnlyTaskManager taskManager, UserPrefs userPrefs) {
        super();
        assert !CollectionUtil.isAnyNull(taskManager, userPrefs);

        logger.fine("Initializing with address book: " + taskManager + " and user prefs " + userPrefs);

        this.taskManager = new TaskManager(taskManager);
        filteredTasks = new FilteredList<>(this.taskManager.getTaskList());
        this.taskManagerCopy = new TaskManager(taskManager);
        this.flag = "empty copy";
    }

    public ModelManager() {
        this(new TaskManager(), new UserPrefs());
    }

    @Override
    public void resetData(ReadOnlyTaskManager newData) {
        taskManager.resetData(newData);
        indicateTaskManagerChanged();
    }

    @Override
    public ReadOnlyTaskManager getTaskManager() {
        return taskManager;
    }

    /** Raises an event to indicate the model has changed */
    public void indicateTaskManagerChanged() {
        raise(new TaskManagerChangedEvent(taskManager));
    }

    @Override
    public synchronized void deleteTask(ReadOnlyTask target) throws TaskNotFoundException {
        taskManager.removeTask(target);
        indicateTaskManagerChanged();
    }

    @Override
    public synchronized void addTask(Task task) {
        taskManager.addTask(task);
        updateFilteredListToShowAll();
        indicateTaskManagerChanged();
    }

    @Override
    public void updateTask(int filteredTaskListIndex, ReadOnlyTask editedTask) {
        assert editedTask != null;

        int taskManagerIndex = filteredTasks.getSourceIndex(filteredTaskListIndex);
        taskManager.updateTask(taskManagerIndex, editedTask);
        indicateTaskManagerChanged();
    }
```
###### \java\seedu\address\model\ReadOnlyTaskManager.java
``` java
package seedu.address.model;

import javafx.collections.ObservableList;
import seedu.address.model.tag.Tag;
import seedu.address.model.task.ReadOnlyTask;

public interface ReadOnlyTaskManager {

    /**
     * Returns an unmodifiable view of the tasks list.
     */
    ObservableList<ReadOnlyTask> getTaskList();

    /**
     * Returns an unmodifiable view of the tags list.
     * This list will not contain any duplicate tags.
     */
    ObservableList<Tag> getTagList();

}
```
###### \java\seedu\address\model\task\date\DateFactory.java
``` java
package seedu.address.model.task.date;

import seedu.address.commons.exceptions.IllegalValueException;

/**
 * A factory class for producing TaskDate objects.
 */
public class DateFactory {

    public DateFactory() {}

    public TaskDate getTaskDateFromString(String dateString) throws IllegalValueException {

        try {
            return ((TaskDate) new TimePeriod(dateString));
        } catch (IllegalValueException e) {
            // Do nothing & continue with next case
        }

        return ((TaskDate) new TimePoint(dateString));
    }

    public TaskDate getUnassignedTime() {
        return (TaskDate) new TimeUnassigned();
    }
}

```
###### \java\seedu\address\model\task\date\DateOnly.java
``` java
package seedu.address.model.task.date;

import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * Represents a date with time.
 *
 * Date is default to be today
 */
public class DateOnly extends DateValue {

    public static final String MESSAGE_DATEONLY_CONSTRAINTS =
        "Allowed format for DateOnly obj: 20/2/2012";

    /**
    * Output format used to display deadline with both date and time.
    * Day, Month Date Year at Hour:Minute
    * Example: Tuesday, April 1 2013 at 23:59
    */
    public static final String READABLE_DATEONLY_OUTPUT_FORMAT = "EEE, MMM dd yyyy";

    public DateOnly() {
        super(new Date());
    }

    public DateOnly(Date date) {
        super(date);
    }

    public DateOnly(DateValue other) {
        super(other);
    }

    public DateOnly getBeginning() {
        Date date = new Date(getYear(), getMonth(), getDate(), 0, 0, 0);
        return new DateOnly(date);
    }

    public DateOnly getEnding() {
        Date date = new Date(getYear(), getMonth(), getDate(), 23, 59, 59);
        return new DateOnly(date);
    }

    @Override
    public boolean after(DateValue date) {
        return getBeginning().getValue().after(date.getValue());
    }

    @Override
    public boolean before(DateValue date) {
        return getEnding().getValue().before(date.getValue());
    }

    @Override
    public String toString() {
        return new SimpleDateFormat(READABLE_DATEONLY_OUTPUT_FORMAT).format(date);
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
            || (other instanceof DateOnly // instanceof handles nulls
                    && this.date.equals(((DateOnly) other).date)); // state check
    }

    @Override
    public int hashCode() {
        return date.hashCode();
    }
}
```
###### \java\seedu\address\model\task\date\DateParser.java
``` java
package seedu.address.model.task.date;

import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.joestelmach.natty.DateGroup;
import com.joestelmach.natty.Parser;

import seedu.address.commons.util.StringUtil;

/**
 * A Parser for TaskTime class.
 *
 * Strings will be converted to lowercase to make parsing easier
 * Default date will be today instead of 01/01/1970 as in Java implementation.
 */
public class DateParser {

    /* Preposition constants */
    public static final String FROM = "from";

    /* Regex constants */
    public static final String TIMEPERIOD_DELIMINATORS_REGEX = "(from|\\sto\\s)";

    public static final String[] DATE_NUMBERIC_REGEX = {
        "\\d{1,4}:\\d{1,2}:\\d{1,4}",
        "\\d{1,4}/\\d{1,2}/\\d{1,4}",
        "\\d{1,4}.\\d{1,2}.\\d{1,4}",
        "\\d{1,4}-\\d{1,2}-\\d{1,4}"
    };

    public static final String[] DATE_NUMBERIC_FORMATS = {
        "dd.MM.yy", "dd/MM/yy", "dd-MM-yy", "dd:MM:yy",
        "dd.MM.yyyy", "dd/MM/yyyy", "dd-MM-yyyy", "dd:MM:yyyy",
        "yyyy.MM.dd", "yyyy/MM/dd", "yyyy-MM-dd", "yyyy:MM:dd"
    };

    public static String convertDateStringToAmericanFormat(String dateString) {

        for (String regex : DATE_NUMBERIC_REGEX) {
            Pattern pattern = Pattern.compile(regex);
            Matcher matcher = pattern.matcher(dateString);

            // Only attempt once
            if (matcher.find()) {
                String matchedSubstr = matcher.group();

                // Converting
                for (String dateFormat : DATE_NUMBERIC_FORMATS) {
                    DateFormat df = new SimpleDateFormat(dateFormat);
                    df.setLenient(false);
                    try {
                        Date date = df.parse(matchedSubstr);
                        String convertedSubstr = (date.getMonth() + 1) + "/"   // Starting at 0
                                                    + date.getDate() + "/"
                                                    + (date.getYear() + 1900); // Years from 1900
                        return matcher.replaceFirst(convertedSubstr);
                    } catch (ParseException e) {
                        // Do nothing
                    }
                }
            }
        }

        // No conversion made
        return dateString;
    }


    /**
     * Parsers.
     */
    public static Optional<DateValue> parseString(String dateString) {
        // Natty only converts dates in American format.
        dateString = convertDateStringToAmericanFormat(dateString);

        Parser parser = new Parser();
        List<DateGroup> groups = parser.parse(dateString);

        // Accept no more than 1 result
        int count = 0;
        for (DateGroup group : groups) {
            count += group.getDates().size();
        }
        if (count > 1) {
            return Optional.ofNullable(null);
        }

        for (DateGroup group : groups) {
            List<Date> dates = group.getDates();
            for (Date date : dates) {
                if (group.isTimeInferred()) {
                    DateOnly result = new DateOnly(date);
                    return Optional.of((DateValue) result);
                } else {
                    DateTime result = new DateTime(date);
                    return Optional.of((DateValue) result);
                }
            }
        }
        return Optional.ofNullable(null);
    }


    public static Optional<DateValue> parseTimePointString(String dateString) {
        dateString = StringUtil.removeRedundantSpaces(dateString);
        dateString = dateString.toLowerCase();

        return parseString(dateString);
    }


    public static Optional<PairResult<DateValue, DateValue>> parseTimePeriodString(String dateString) {
        dateString = StringUtil.removeRedundantSpaces(dateString);
        dateString = dateString.toLowerCase();

        if (!dateString.startsWith(FROM)) {
            return Optional.ofNullable(null);
        }

        String[] texts = dateString.split(TIMEPERIOD_DELIMINATORS_REGEX);
        // DateString must be splitted into exactly 3 parts (empty, begin date and end date)
        if (texts.length != 3) {
            return Optional.ofNullable(null);
        }
        String beginDateString = texts[1];
        String endDateString = texts[2];

        Optional<DateValue> beginDate = parseTimePointString(beginDateString);
        Optional<DateValue> endDate = parseTimePointString(endDateString);

        if (beginDate.isPresent() && endDate.isPresent()) {
            return Optional.of(new PairResult<DateValue, DateValue>(beginDate.get(), endDate.get()));
        } else {
            return Optional.ofNullable(null);
        }
    }

    /**
     * A PairResult class for methods that return 2 objects as result.
     */
    public static class PairResult<T, S> {

        public T first;
        public S second;

        public PairResult(T first, S second) {
            this.first = first;
            this.second = second;
        }

        @Override
        public boolean equals(Object other) {
            return other == this // short circuit if same object
                || (other instanceof PairResult // instanceof handles nulls
                        && this.first.equals(((PairResult) other).first) // state check
                        && this.second.equals(((PairResult) other).second));
        }

        @Override
        public int hashCode() {
            return Objects.hash(first, second);
        }
    }

}
```
###### \java\seedu\address\model\task\date\DateTime.java
``` java
package seedu.address.model.task.date;

import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * Represents a date with time.
 *
 * Date is default to be today
 */
public class DateTime extends DateValue {

    public static final String MESSAGE_DATETIME_CONSTRAINTS =
        "Allowed format for DateTime obj: 20/2/2012 10:12 pm";

    /**
    * Output format used to display deadline with both date and time.
    * Day, Month Date Year at Hour:Minute
    * Example: Tuesday, April 1 2013 at 23:59
    */
    public static final String READABLE_DATETIME_OUTPUT_FORMAT = "EEE, MMM dd yyyy, hh:mm aaa";

    public DateTime() {
        super(new Date());
    }

    public DateTime(Date date) {
        super(date);
    }

    public DateTime(DateValue other) {
        super(other);
    }

    /**
     * Combine date and time from 2 DateValue objects with date taken from the first
     * and time taken from the second.
     */
    public DateTime(Date date, Date time) {
        super(new Date(date.getYear(), date.getMonth(), date.getDate(),
                                time.getHours(), time.getMinutes()));
    }

    public DateTime getBeginning() {
        return new DateTime(this.date);
    }

    public DateTime getEnding() {
        return new DateTime(this.date);
    }

    @Override
    public String toString() {
        return new SimpleDateFormat(READABLE_DATETIME_OUTPUT_FORMAT).format(date);
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
            || (other instanceof DateTime // instanceof handles nulls
                    && this.date.equals(((DateTime) other).date)); // state check
    }

    @Override
    public int hashCode() {
        return date.hashCode();
    }
}
```
###### \java\seedu\address\model\task\date\DateValue.java
``` java
package seedu.address.model.task.date;

import java.util.Date;

/**
 * An interface represents date and time.
 */
public abstract class DateValue {

    protected final Date date;

    public DateValue() {
        this.date = new Date();
    }

    public DateValue(Date date) {
        this.date = new Date(date.getYear(), date.getMonth(), date.getDate(),
                                date.getHours(), date.getMinutes());
    }

    public DateValue(DateValue dateValue) {
        this(dateValue.getValue());
    }

    /* Getters */
    public Date getValue() {
        return date;
    }

    public int getYear() {
        return date.getYear();
    }

    public int getMonth() {
        return date.getMonth();
    }

    public int getDate() {
        return date.getDate();
    }

    public int getDay() {
        return date.getDay();
    }

    public int getHours() {
        return date.getHours();
    }

    public int getMinutes() {
        return date.getMinutes();
    }

    public int getSeconds() {
        return date.getSeconds();
    }

    public long getTime() {
        return date.getTime();
    }

    /* Setters */
    public DateValue setYear(int year) {
        this.date.setYear(year);
        return this;
    }

    public DateValue setMonth(int month) {
        this.date.setMonth(month);
        return this;
    }

    public DateValue setDate(int date) {
        this.date.setDate(date);
        return this;
    }

    public DateValue setHours(int hours) {
        this.date.setHours(hours);
        return this;
    }

    public DateValue setMinutes(int minutes) {
        this.date.setMinutes(minutes);
        return this;
    }

    public DateValue setSeconds(int seconds) {
        this.date.setSeconds(seconds);
        return this;
    }

    public DateValue setTime(long milliseconds) {
        this.date.setTime(milliseconds);
        return this;
    }

    public boolean after(DateValue date) {
        return this.date.after(date.getValue());
    }

    public boolean before(DateValue date) {
        return this.date.before(date.getValue());
    }

    public abstract DateValue getBeginning();
    public abstract DateValue getEnding();

    @Override
    public String toString() {
        return date.toString();
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
            || (other instanceof DateValue // instanceof handles nulls
                    && this.date.equals(((DateValue) other).date)); // state check
    }

    @Override
    public int hashCode() {
        return date.hashCode();
    }
}
```
###### \java\seedu\address\model\task\date\TaskDate.java
``` java
package seedu.address.model.task.date;

/**
 * An interface represents date, time or a timeperiod.
 */
public interface TaskDate {

    /* Floating taskDate contains no value */
    public boolean isFloating();
    public boolean hasPassed();
    public boolean isHappeningToday();
    public boolean isHappeningTomorrow();

    public DateValue getBeginning();
    public DateValue getEnding();
}
```
###### \java\seedu\address\model\task\date\TimePeriod.java
``` java
package seedu.address.model.task.date;

import java.util.Objects;
import java.util.Optional;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.commons.util.DateUtil;
import seedu.address.model.task.date.DateParser.PairResult;

/**
 * Represents a Time Period with beginning and ending dates.
 */
public class TimePeriod implements TaskDate {

    public static final String MESSAGE_TIMEPERIOD_CONSTRAINTS =
        "Allowed format for TimePeriod obj: from [Valid Date] to [Valid Date]";

    public static final String OUTPUT_FORMAT = "from %s to %s";

    private final DateValue beginDate;
    private final DateValue endDate;

    public TimePeriod(String dateString) throws IllegalValueException {
        Optional<PairResult<DateValue, DateValue>> parseResult = DateParser.parseTimePeriodString(dateString);
        if (!parseResult.isPresent()) {
            throw new IllegalValueException(MESSAGE_TIMEPERIOD_CONSTRAINTS);
        }
        beginDate = parseResult.get().first;
        endDate = parseResult.get().second;
        if (beginDate.after(endDate)) {
            throw new IllegalValueException(MESSAGE_TIMEPERIOD_CONSTRAINTS);
        }
    }

    /* Floating taskDate contains no value */
    public boolean isFloating() {
        return false;
    }

    public boolean hasPassed() {
        return endDate.before(DateUtil.getToday());
    }

    public boolean isHappeningToday() {
        DateValue today = DateUtil.getToday();
        return DateUtil.haveIntersection(beginDate.getBeginning(), endDate.getEnding(),
                                DateUtil.getBeginOfDay(today), DateUtil.getEndOfDay(today));
    }

    public boolean isHappeningTomorrow() {
        DateValue tmr = DateUtil.getTomorrow();
        return DateUtil.haveIntersection(beginDate.getBeginning(), endDate.getEnding(),
                                DateUtil.getBeginOfDay(tmr), DateUtil.getEndOfDay(tmr));
    }

    public DateValue getBeginning() {
        return beginDate.getBeginning();
    }

    public DateValue getEnding() {
        return endDate.getEnding();
    }

    @Override
    public String toString() {
        return String.format(OUTPUT_FORMAT, beginDate.toString(), endDate.toString());
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
            || (other instanceof TimePeriod // instanceof handles nulls
                    && this.beginDate.equals(((TimePeriod) other).beginDate) // state check
                    && this.endDate.equals(((TimePeriod) other).endDate));
    }

    @Override
    public int hashCode() {
        return Objects.hash(beginDate, endDate);
    }
}
```
###### \java\seedu\address\model\task\date\TimePoint.java
``` java
package seedu.address.model.task.date;

import java.util.Optional;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.commons.util.DateUtil;

/**
 * Represents a Time Period with beginning and ending dates.
 */
public class TimePoint implements TaskDate {

    public static final String MESSAGE_TIMEPOINT_CONSTRAINTS =
        "Allowed format for TimePoint obj: [preposition] [Valid Date]";

    public static final String OUTPUT_FORMAT = "%s";

    private final DateValue date;

    public TimePoint(String dateString) throws IllegalValueException {
        Optional<DateValue> parseResult = DateParser.parseTimePointString(dateString);
        if (!parseResult.isPresent()) {
            throw new IllegalValueException(MESSAGE_TIMEPOINT_CONSTRAINTS);
        }
        date = parseResult.get();
    }

    public boolean isFloating() {
        return false;
    }

    public boolean hasPassed() {
        return date.before(DateUtil.getToday());
    }

    public boolean isHappeningToday() {
        DateValue today = DateUtil.getToday();
        return DateUtil.haveIntersection(date.getBeginning(), date.getEnding(),
                                DateUtil.getBeginOfDay(today), DateUtil.getEndOfDay(today));
    }

    public boolean isHappeningTomorrow() {
        DateValue tmr = DateUtil.getTomorrow();
        return DateUtil.haveIntersection(date.getBeginning(), date.getEnding(),
                                DateUtil.getBeginOfDay(tmr), DateUtil.getEndOfDay(tmr));
    }

    public DateValue getBeginning() {
        return date.getBeginning();
    }

    public DateValue getEnding() {
        return date.getEnding();
    }

    @Override
    public String toString() {
        return String.format(OUTPUT_FORMAT, date.toString());
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
            || (other instanceof TimePoint // instanceof handles nulls
                    && this.date.equals(((TimePoint) other).date)); // state check
    }

    @Override
    public int hashCode() {
        return date.hashCode();
    }
}
```
###### \java\seedu\address\model\task\date\TimeUnassigned.java
``` java
package seedu.address.model.task.date;

/**
 * Represents a Time Value that is unassigned by user.
 */
public class TimeUnassigned implements TaskDate {

    public final String MESSAGE_TIMEUNASSIGNED_CONSTRAINTS =
        "Leave deadline field empty for task with time unassigned";

    public final String MESSAGE_UNASSIGNED_DATE = "Unassigned";

    public TimeUnassigned() {}

    /**
     * For task with unassigned time, only isfloating is true
     */
    public boolean isFloating() {
        return true;
    }

    public boolean hasPassed() {
        return false;
    }

    public boolean isHappeningToday() {
        return false;
    }

    public boolean isHappeningTomorrow() {
        return false;
    }

    public DateValue getBeginning() {
        return null;
    }

    public DateValue getEnding() {
        return null;
    }

    @Override
    public String toString() {
        return MESSAGE_UNASSIGNED_DATE;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
            || (other instanceof TimeUnassigned); // instanceof handles nulls
    }

    @Override
    public int hashCode() {
        return MESSAGE_UNASSIGNED_DATE.hashCode();
    }
}
```
###### \java\seedu\address\model\task\Deadline.java
``` java
package seedu.address.model.task;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.model.task.date.DateFactory;
import seedu.address.model.task.date.TaskDate;

/**
 * Represents a Task's deadline in the TaskManager.
 * Guarantees: immutable; is valid as declared in {@link #isValidDeadline(String)}
 */
public class Deadline {

    public static final String MESSAGE_DEADLINE_CONSTRAINTS =
        "Deadline accepts following formats: 30-10-2012 10:10 am; Sun, March 14 2017 23:59, ...\n"
        + "Please make sure valid existing date is used";


    public final TaskDate date;

    public Deadline() {
        DateFactory dateFactory = new DateFactory();
        date = dateFactory.getUnassignedTime();
    }

    /**
     * Constructor for Deadline.
     */
    public Deadline(String dateString) throws IllegalValueException {
        assert dateString != null;

        DateFactory dateFactory = new DateFactory();
        try {
            date = dateFactory.getTaskDateFromString(dateString);
        } catch (IllegalValueException e) {
            throw new IllegalValueException(MESSAGE_DEADLINE_CONSTRAINTS);
        }
    }

    public static boolean isValidDeadline(String dateString) {
        DateFactory dateFactory = new DateFactory();
        try {
            dateFactory.getTaskDateFromString(dateString);
            return true;
        } catch (IllegalValueException e) {
            return false;
        }
    }

    public boolean isFloating() {
        return date.isFloating();
    }

    public boolean isOverdue() {
        return date.hasPassed();
    }

    public boolean isToday() {
        return date.isHappeningToday();
    }

    public boolean isTomorrow() {
        return date.isHappeningTomorrow();
    }

    @Override
    public String toString() {
        return date.toString();
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
            || (other instanceof Deadline // instanceof handles nulls
                    && this.date.equals(((Deadline) other).date)); // state check
    }

    @Override
    public int hashCode() {
        return date.hashCode();
    }

}
```
###### \java\seedu\address\model\task\Description.java
``` java
package seedu.address.model.task;

/**
 * Represents a Task's description in the TaskManager.
 * Guarantees: immutable;
 */
public class Description {

    public final String defaultDescription = "";

    public final String description;

    public Description() {
        this.description = defaultDescription;
    }

    /**
     * Description just needs to be not null
     */
    public Description(String description) {
        assert description != null;
        this.description = description.trim();
    }


    @Override
    public String toString() {
        return description;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Description // instanceof handles nulls
                && this.description.equals(((Description) other).description)); // state check
    }

    @Override
    public int hashCode() {
        return description.hashCode();
    }

}
```
###### \java\seedu\address\model\task\Name.java
``` java
package seedu.address.model.task;

import seedu.address.commons.exceptions.IllegalValueException;

/**
 * Represents a Task's name in the TaskManager.
 * Guarantees: immutable; is valid as declared in {@link #isValidName(String)}
 */
public class Name {

    public static final String MESSAGE_NAME_CONSTRAINTS =
            "Task names should only contain alphanumeric characters and spaces, and it should not be blank";

    /*
     * The first character of the address must not be a whitespace,
     * otherwise " " (a blank string) becomes a valid input.
     */
    public static final String NAME_VALIDATION_REGEX = "[\\p{Alnum}][\\p{Alnum} ]*";

    public final String name;

    /**
     * Validates given name.
     *
     * @throws IllegalValueException if given name string is invalid.
     */
    public Name(String name) throws IllegalValueException {
        assert name != null;
        String trimmedName = name.trim();
        if (!isValidName(trimmedName)) {
            throw new IllegalValueException(MESSAGE_NAME_CONSTRAINTS);
        }
        this.name = trimmedName;
    }

    /**
     * Returns true if a given string is a valid person name.
     */
    public static boolean isValidName(String test) {
        return test.matches(NAME_VALIDATION_REGEX);
    }


    @Override
    public String toString() {
        return name;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Name // instanceof handles nulls
                && this.name.equals(((Name) other).name)); // state check
    }

    @Override
    public int hashCode() {
        return name.hashCode();
    }

}
```
###### \java\seedu\address\model\task\ReadOnlyTask.java
``` java
package seedu.address.model.task;

import seedu.address.model.tag.UniqueTagList;

/**
 * A read-only immutable interface for a Task in the addressbook.
 */
public interface ReadOnlyTask {

    Name getName();
    Deadline getDeadline();
    Description getDescription();
    UniqueTagList getTags();
    Status getStatus();

    /**
     * Returns true if both have the same state. (interfaces cannot override .equals)
     */
    default boolean isSameStateAs(ReadOnlyTask other) {
        return other == this // short circuit if same object
                || (other != null // this is first to avoid NPE below
                && other.getName().equals(this.getName()) // state checks here onwards
                && other.getDeadline().equals(this.getDeadline())
                && other.getDescription().equals(this.getDescription())
                && other.getTags().equals(this.getTags())
                && other.getStatus().equals(this.getStatus()));
    }

    /**
     * Formats the task as text, showing all contact details.
     */
    default String getAsText() {
        final StringBuilder builder = new StringBuilder();
        builder.append(" Name: ")
                .append(getName())
                .append(" Deadline: ")
                .append(getDeadline())
                .append(" Description: ")
                .append(getDescription())
                .append(" Status: ")
                .append(getStatus());
        return builder.toString();
    }

}
```
###### \java\seedu\address\model\task\Status.java
``` java
package seedu.address.model.task;

import seedu.address.commons.exceptions.IllegalValueException;

/**
 * Represents a Task's status in the TaskManager.
 * Guarantees: immutable; is valid as declared in {@link #isValidStatus(String)}
 * Task status can be one of the following values:
 *      + Done
 *      + Floating
 *      + Overdue
 *      + Today
 *      + Tomorrow
 *      + This Week
 *      + future
 *  ** Status should not be used when comparing tasks as it is volatile and changes
 *  depending on current time **
 */
public class Status {

    public static final String MESSAGE_STATUS_CONSTRAINTS =
        "User can only set task status as Undone or Done";

    /*
     * The first character of the address must not be a whitespace,
     * otherwise " " (a blank string) becomes a valid input.
     */
    public static final String[] ALLOWED_STATUS_VALUES = {
        "Done", "Undone", "Floating", "Overdue",
        "Today", "Tomorrow", "Future"
    };

    /* Status values string contants */
    public static final String DONE = "Done";
    public static final String UNDONE = "Undone";
    public static final String FLOATING = "Floating";
    public static final String OVERDUE = "Overdue";
    public static final String TODAY = "Today";
    public static final String TOMORROW = "Tomorrow";
    public static final String FUTURE = "Future";

    public String status;

    public Status() {
        status = UNDONE;
    }

    /**
     * Validates given status.
     *
     * @throws IllegalValueException if given status string is invalid.
     */
    public Status(String status) throws IllegalValueException {
        assert status != null;
        for (String statusString : ALLOWED_STATUS_VALUES) {
            // Compare insensitively
            if (statusString.toLowerCase().equals(status.toLowerCase())) {
                this.status = status;
                return;
            }
        }
        throw new IllegalValueException(MESSAGE_STATUS_CONSTRAINTS);
    }

    /**
     * Returns true if a given string is a valid task status.
     */
    public static boolean isValidStatus(String status) {
        for (String statusString : ALLOWED_STATUS_VALUES) {
            // Compare insensitively
            if (statusString.toLowerCase().equals(status.toLowerCase())) {
                return true;
            }
        }
        return false;
    }

    @Override
    public String toString() {
        return status;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Status // instanceof handles nulls
                && this.status.equals(((Status) other).status)); // state check
    }

    @Override
    public int hashCode() {
        return status.hashCode();
    }

    public void setStatus(String status) {
        this.status = status;
    }

}
```
###### \java\seedu\address\model\task\Task.java
``` java
package seedu.address.model.task;

import java.util.Objects;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.commons.util.CollectionUtil;
import seedu.address.model.tag.Tag;
import seedu.address.model.tag.UniqueTagList;

/**
 * Represents a Task in Task Manager.
 *
 * Status should be updated everytime task's deadline changes
 */
public class Task implements ReadOnlyTask {

    private static final String DEFAULT_DESCRIPTION = "No description";

    //private IdentificationNumber ID;
    private Name name;
    private Description description;
    private Deadline deadline;
    private Status status;

    private UniqueTagList tags;

    /**
     * Name is required and must not be null
     */
    public Task(Name name, Object... params) {
        assert !CollectionUtil.isAnyNull(name);

        this.name = name;
        this.deadline = new Deadline();
        this.description = new Description(DEFAULT_DESCRIPTION);
        this.tags = new UniqueTagList();

        // Call update status immediately after creation
        this.status = new Status();

        // Optional parameters
        // ID tends to be set after Task creation,
        // so it is also included in optional params
        for (Object param : params) {
            if (param instanceof Description) {
                this.description = (Description) param;

            } else if (param instanceof Deadline) {
                this.deadline = (Deadline) param;

            } else if (param instanceof Status) {
                this.status = (Status) param;

            } else if (param instanceof UniqueTagList) {
                this.tags.mergeFrom((UniqueTagList) param);

            } else if (param instanceof Tag) {
                this.tags.add((Tag) param);
            }
        }
    }

    /**
     * Creates a copy of the given ReadOnlyTask.
     */
    public Task(ReadOnlyTask source) {
        this(source.getName(), source.getDeadline(), source.getDescription(), source.getStatus(), source.getTags());
    }

    public Task(Name name2, Description description2, Deadline deadline2,
        UniqueTagList uniqueTagList) {
        // TODO Auto-generated constructor stub
    }

    /**
     * Getters and setters
     */

    /*
    public Task setID(IdentificationNumber ID) {
        this.ID = ID;
        return this;
    }

    @Override
    public IdentificationNumber getID() {
        return ID;
    }

    public boolean isIDUnassigned() {
        return ID.equals(DEFAULT_ID);
    }
    */

    public Task setName(Name name) {
        assert name != null;
        this.name = name;
        return this;
    }

    @Override
    public Name getName() {
        return name;
    }

    public Task setDeadline(Deadline deadline) {
        assert deadline != null;
        this.deadline = deadline;
        // Status value depends on Deadline value and should be updated here
        updateStatus();
        return this;
    }

    @Override
    public Deadline getDeadline() {
        return deadline;
    }

    public Task setDescription(Description description) {
        if (description == null) {
            this.description = new Description(DEFAULT_DESCRIPTION);
        } else {
            this.description = description;
        }
        return this;
    }

    @Override
    public Description getDescription() {
        return description;
    }

    /**
     * Replaces this task's tags with the tags in the argument tag list.
     */
    public Task setTags(UniqueTagList replacement) {
        tags.setTags(replacement);
        return this;
    }

    @Override
    public UniqueTagList getTags() {
        return new UniqueTagList(tags);
    }

    /**
     * Updates this task with the details of {@code replacement}.
     */
    public Task resetData(ReadOnlyTask replacement) {
        assert replacement != null;

        this.setName(replacement.getName());
        this.setDeadline(replacement.getDeadline());
        this.setDescription(replacement.getDescription());
        this.setStatus(replacement.getStatus());
        this.setTags(replacement.getTags());
        return this;
    }

    @Override
    public Status getStatus() {
        return updateStatus();
    }

    public Task setStatus(Status status) {
        this.status = status;
        updateStatus();
        return this;
    }

    public Status updateStatus() {
        String currentStatus = status.toString();
        if (currentStatus.equals(Status.DONE)) {
            // No change
            return status;
        } else {
            // Update status base on Deadline and current time
            try {
                if (deadline.isFloating()) {
                    return status = new Status(Status.FLOATING);

                } else if (deadline.isOverdue()) {
                    return status = new Status(Status.OVERDUE);

                } else if (deadline.isToday()) {
                    return status = new Status(Status.TODAY);

                } else if (deadline.isTomorrow()) {
                    return status = new Status(Status.TOMORROW);

                } else {
                    return status = new Status(Status.FUTURE);
                }
            } catch (IllegalValueException e) {
                // Impossible
                return status;
            }
        }
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ReadOnlyTask // instanceof handles nulls
                && this.isSameStateAs((ReadOnlyTask) other));
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(name, deadline, description);
    }

    @Override
    public String toString() {
        return getAsText();
    }

}
```
###### \java\seedu\address\ui\CommandBox.java
``` java
    /**
     * List of key events that commandbox handles:
     * - Alt + Number key: Change expanded group
     * - UP, DOWN: Change to previously typed inputs
     * - PAGEUP, PAGEDOWN: Scroll expanded group up and down
     */
    @FXML
    private void handleKeyReleased(KeyEvent event) {
        if (event.isAltDown()) {
            if (event.getCode().isDigitKey()) {
                String keyCode = event.getCode().toString();
                int key = keyCode.charAt(keyCode.length() - 1) - '0';
                changeExpandedGroup(key);
            }
        } else {
            switch (event.getCode()) {

            case UP:
            case KP_UP:
                moveUpHistoryStack();
                break;

            case DOWN:
            case KP_DOWN:
                moveDownHistoryStack();
                break;

            case PAGE_UP:
                broadcastPageUpEvents();
                break;

            case PAGE_DOWN:
                broadcastPageDownEvents();
                break;

            case ENTER:
                handleInputEntered();
                break;

            default:
                break;
            }
        }
    }

    private void changeExpandedGroup(int groupIndex) {
        EventsCenter.getInstance().post(new ExpandingEvent(groupIndex));
    }

    private void broadcastPageUpEvents() {
        EventsCenter.getInstance().post(new ScrollingEvent(ScrollingEvent.SCROLL_UP));
    }

    private void broadcastPageDownEvents() {
        EventsCenter.getInstance().post(new ScrollingEvent(ScrollingEvent.SCROLL_DOWN));
    }

    private void moveUpHistoryStack() {
        historyIndex = Math.max(historyIndex - 1, 0);
        String text = history.get(historyIndex);
        commandTextField.setText(text);
        commandTextField.end();
        logger.info("Key UP pressed: text changed to " + text);
    }

    private void moveDownHistoryStack() {
        historyIndex = Math.min(historyIndex + 1, history.size() - 1);
        String text = history.get(historyIndex);
        commandTextField.setText(text);
        commandTextField.end();
        logger.info("Key DOWN pressed: text changed to " + text);
    }

    private void handleInputEntered() {
        // Update history
        history.set(history.size() - 1, commandTextField.getText());

        try {
            CommandResult commandResult = logic.execute(commandTextField.getText());
            history.add(EMPTY_STRING);
            historyIndex = history.size() - 1;

            // process result of the command
            setStyleToIndicateCommandSuccess();
            commandTextField.clear();
            logger.info("Result: " + commandResult.feedbackToUser);
            raise(new NewResultAvailableEvent(commandResult.feedbackToUser));

        } catch (CommandException e) {
            // handle command failure
            historyIndex = history.size() - 1;
            setStyleToIndicateCommandFailure();
            logger.info("Invalid command: " + commandTextField.getText());
            raise(new NewResultAvailableEvent(e.getMessage()));
        }
    }
```
###### \java\seedu\address\ui\TaskCard.java
``` java
    private void initTags(ReadOnlyTask task) {
        for (Tag tag : task.getTags()) {
            // Get color of this tag or randomly create a new one
            UiColor tagColor = (tagColorMap.containsKey(tag.tagName) ?
                                tagColorMap.get(tag.tagName) :
                                UiColor.getRandomColor());
            UiColor textColor = UiColor.WHITE;
            // Update HashMap
            tagColorMap.put(tag.tagName, tagColor);

            // Create tag label
            Label tagLabel = new Label(tag.tagName);
            String css = String.format(TAG_LABEL_CSS, textColor.toString(), tagColor.toString());
            tagLabel.setStyle(css);

            tags.getChildren().add(tagLabel);
        }
    }
}
```
###### \java\seedu\address\ui\TaskGroupPanel.java
``` java
package seedu.address.ui;

import java.util.List;
import java.util.logging.Logger;

import com.google.common.eventbus.Subscribe;

import javafx.collections.ObservableList;
import javafx.fxml.FXML;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.TitledPane;
import javafx.scene.layout.Region;
import javafx.scene.layout.VBox;
import seedu.address.commons.core.EventsCenter;
import seedu.address.commons.core.LogsCenter;
import seedu.address.commons.events.ui.ScrollingEvent;
import seedu.address.commons.events.ui.ShowTaskGroupEvent;
import seedu.address.model.task.ReadOnlyTask;

/**
 * Panel containing a group of tasks.
 */
public class TaskGroupPanel extends UiPart<Region> {

    private final Logger logger = LogsCenter.getLogger(TaskGroupPanel.class);
    private static final String FXML = "TaskGroupPanel.fxml";

    @FXML
    private TitledPane titledPane;

    @FXML
    private ScrollPane scrollPane;

    @FXML
    private VBox taskGroupView;

    private String title;

    public TaskGroupPanel(String title, ObservableList<ReadOnlyTask> taskList, List<Integer> taskIndexList) {
        super(FXML);
        setTitle(title, taskList.size());
        setExpandingListener();
        createTaskGroupView(taskList, taskIndexList);
        closeTitlePane();
        registerAsAnEventHandler(this);
    }

    public void closeTitlePane() {
        titledPane.setExpanded(false);
    }

    public void openTitlePane() {
        titledPane.setExpanded(true);
    }

    public void setTitle(String title, int taskCount) {
        this.title = title;
        titledPane.setText(title + " (" + taskCount + ")");
    }

    public String getTitle() {
        return this.title;
    }

    public boolean isExpanded() {
        return titledPane.isExpanded();
    }

    public double getScrollPosition() {
        return scrollPane.getVvalue();
    }

    public void scrollToEnd() {
        openTitlePane();
        safelyScrollTo(scrollPane.getVmax());
    }

    public void scrollTo(double vValue) {
        openTitlePane();
        safelyScrollTo(vValue);
    }

    /**
     * Return the scroll value every time user presses pageup or pagedown
     */
    public double getScrollValuePerKeyPress() {
        double fullHeight = taskGroupView.getHeight();
        double scrollHeight = 150.0;  // 200 px at a time
        return scrollHeight / fullHeight;
    }

    public void scrollToNextPage() {
        double viewPercentage = getScrollValuePerKeyPress();
        scrollTo(scrollPane.getVvalue() + viewPercentage);
    }

    public void scrollToPrevPage() {
        double viewPercentage = getScrollValuePerKeyPress();
        scrollTo(scrollPane.getVvalue() - viewPercentage);
    }

    public int getTaskCount() {
        return taskGroupView.getChildren().size();
    }

    // Value used for scroling must be within vmax and vmin
    public void safelyScrollTo(double vValue) {
        vValue = Math.min(vValue, scrollPane.getVmax());
        vValue = Math.max(vValue, scrollPane.getVmin());
        scrollPane.setVvalue(vValue);
    }

    /**
     * Instantiate TaskCard objects and add them to taskListView.
     */
    private void createTaskGroupView(ObservableList<ReadOnlyTask> taskList, List<Integer> taskIndexList) {
        taskGroupView.getChildren().clear();
        int index = 0;
        for (ReadOnlyTask task : taskList) {
            TaskCard taskCard = new TaskCard(task, taskIndexList.get(index) + 1);
            taskGroupView.getChildren().add(taskCard.getRoot());
            index++;
        }
    }

    private void setExpandingListener() {
        titledPane.expandedProperty().addListener((obs, oldValue, newValue) -> {
            if (newValue && newValue != oldValue) {
                EventsCenter.getInstance().post(new ShowTaskGroupEvent(getTitle()));
            }
        });
    }

    @Subscribe
    private void handleScrollingEvent(ScrollingEvent event) {
        if (titledPane.isExpanded()) {
            if (event.scrollType == ScrollingEvent.SCROLL_DOWN) {
                scrollToNextPage();
            } else {
                scrollToPrevPage();
            }
        }
    }

    @Subscribe
    private void handleShowTaskGroupEvent(ShowTaskGroupEvent event) {
        if (!getTitle().equals(event.title) && titledPane.isExpanded()) {
            closeTitlePane();
        }
    }

}
```
###### \java\seedu\address\ui\TaskListPanel.java
``` java
package seedu.address.ui;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.logging.Logger;

import com.google.common.eventbus.Subscribe;

import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.fxml.FXML;
import javafx.scene.control.SplitPane;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.Region;
import javafx.scene.layout.VBox;

import seedu.address.commons.core.LogsCenter;
import seedu.address.commons.events.ui.ChangeViewRequestEvent;
import seedu.address.commons.events.ui.ExpandingEvent;
import seedu.address.commons.util.FxViewUtil;
import seedu.address.model.task.ReadOnlyTask;
import seedu.address.model.task.Status;

/**
 * Panel containing the list of groups of tasks.
 *
 * - viewTasksWithStatus decides which groups of task will be displayed by using
 *   given statusList.
 * - Upon taskList change event, the program do the following:
 *      + Save the current view (which panel is expanded and scroll position)
 *      + Reload view with new data
 *      + Restore view state
 * - taskIndexMap stores original index of tasks in taskList, because when we distribute
 *   tasks to different groups, the index of them might not be in consecutive order anymore.
 */
public class TaskListPanel extends UiPart<Region> {
    private final Logger logger = LogsCenter.getLogger(TaskListPanel.class);
    private static final String FXML = "TaskListPanel.fxml";

    // Additional status to view all tasks
    private static final String ALL_TASKS = "All";
    private static final String CALENDAR = "Calendar";
    private static final String UNFINISHED = "Unfinished";

    private HashMap<String, ObservableList<ReadOnlyTask>> taskListMap;
    private HashMap<String, ArrayList<Integer>> taskIndexMap;
    private HashMap<String, TaskGroupPanel> childGroupMap;


    @FXML
    private VBox taskListView;

    private String lastExpanded;
    private int lastTaskCount;
    private double lastScrollPosition;

    private ObservableList<ReadOnlyTask> taskList;
    private List<String> statusList;

    private ListChangeListener taskListListener;

    public TaskListPanel(AnchorPane taskListPlaceholder, ObservableList<ReadOnlyTask> taskList) {
        super(FXML);
        setTaskList(taskList);
        viewTasksWithStatus(Arrays.asList(Status.DONE, UNFINISHED));
        addToPlaceholder(taskListPlaceholder);
        registerAsAnEventHandler(this);
    }

    public void setTaskList(ObservableList<ReadOnlyTask> taskList) {
        this.taskList = taskList;
    }

    public void setStatusList(List<String> statusList) {
        this.statusList = statusList;
    }

    private void viewTasksWithStatus(List<String> statusList) {
        setStatusList(statusList);
        initTaskListsByStatus(statusList);
        createTaskListView(statusList);

        // update taskList listener
        if (taskListListener != null) {
            taskList.removeListener(taskListListener);
        }
        taskListListener = new ListChangeListener<ReadOnlyTask>() {
            public void onChanged(Change<? extends ReadOnlyTask> change) {
                saveScrollingState(statusList);
                initTaskListsByStatus(statusList);
                createTaskListView(statusList);
                restoreScrollingState();
            }
        };
        taskList.addListener(taskListListener);
    }

    /** Update scrolling state of its child nodes */
    private void saveScrollingState(List<String> statusList) {
        lastExpanded = null;
        for (String status : statusList) {
            TaskGroupPanel childNode = childGroupMap.get(status);
            if (childNode.isExpanded()) {
                lastExpanded = childNode.getTitle();
                lastScrollPosition = childNode.getScrollPosition();
                lastTaskCount = childNode.getTaskCount();
                return;
            }
        }
    }

    /** Restore scrolling state based on previously collected info. */
    private void restoreScrollingState() {
        if (lastExpanded != null) {
            TaskGroupPanel childNode = childGroupMap.get(lastExpanded);
            if (childNode.getTaskCount() > lastTaskCount) {
                childNode.scrollToEnd();
            } else {
                childNode.scrollTo(lastScrollPosition);
            }
        }
    }

    /**
     * Groups tasks based on task status.
     *
     * A hashMap maps from status to corresponding task lists and index lists.
     * Index list contains original index of tasks in taskList.
     */
    private void initTaskListsByStatus(List<String> statusList) {
        // Clear current data
        taskListMap = new HashMap<String, ObservableList<ReadOnlyTask>>();
        taskIndexMap = new HashMap<String, ArrayList<Integer>>();
        for (String status : statusList) {
            taskListMap.put(status, FXCollections.observableArrayList());
            taskIndexMap.put(status, new ArrayList<Integer>());
        }

        // Load new data
        int index = 0;
        for (ReadOnlyTask task : taskList) {
            String taskStatus = task.getStatus().toString();
            if (taskListMap.containsKey(taskStatus)) {
                taskListMap.get(taskStatus).add(task);
                taskIndexMap.get(taskStatus).add(index);
            } else if (taskListMap.containsKey(ALL_TASKS)) {
                taskListMap.get(ALL_TASKS).add(task);
                taskIndexMap.get(ALL_TASKS).add(index);
            } else if (taskListMap.containsKey(UNFINISHED) && taskStatus != Status.DONE) {
                taskListMap.get(UNFINISHED).add(task);
                taskIndexMap.get(UNFINISHED).add(index);
            }
            index++;
        }
    }

    /**
     * Instantiate TaskGroupPanel objects and add them to taskListView.
     *
     * The last group that is non-empty will be expanded
     */
    private void createTaskListView(List<String> statusList) {
        taskListView.getChildren().clear();
        childGroupMap = new HashMap<String, TaskGroupPanel>();
        TaskGroupPanel lastOne = null;

        for (String status : statusList) {
            // Create new task group & add them to current view.
            ObservableList<ReadOnlyTask> tasks = taskListMap.get(status);
            ArrayList<Integer> taskIndexList = taskIndexMap.get(status);
            TaskGroupPanel taskGroupPanel = new TaskGroupPanel(status, tasks, taskIndexList);

            childGroupMap.put(status, taskGroupPanel);
            taskListView.getChildren().add(taskGroupPanel.getRoot());
            if (!taskIndexList.isEmpty()) {
                lastOne = taskGroupPanel;
            }
        }

        // Expand the last group that is non-empty
        if (lastOne != null) {
            lastOne.openTitlePane();
        }
    }

    private void addToPlaceholder(AnchorPane placeHolderPane) {
        SplitPane.setResizableWithParent(placeHolderPane, false);
        FxViewUtil.applyAnchorBoundaryParameters(getRoot(), 0.0, 0.0, 0.0, 0.0);
        placeHolderPane.getChildren().add(getRoot());
    }

    private List<String> removeDuplicateViews(List<String> views) {
        ArrayList<String> resView = new ArrayList<String>();
        for (String view : views) {
            if (!resView.contains(view)) {
                resView.add(view);
            }
        }
        return resView;
    }

    @Subscribe
    private void handleExpandingEvent(ExpandingEvent event) {
        int groupIndex = event.groupIndex;
        logger.info("User expand group by key combination: Alt + " + groupIndex);
        // groupIndex is in 1-based index, convert to 0-based
        if (groupIndex >= 1 && groupIndex <= statusList.size()) {
            String groupName = statusList.get(groupIndex - 1);
            TaskGroupPanel group = childGroupMap.get(groupName);
            group.openTitlePane();
        }
    }

    @Subscribe
    private void handleChangeViewRequestEvent(ChangeViewRequestEvent event) {
        ArrayList<String> groupsToView = new ArrayList<String>();
        for (String group : event.viewGroups) {
            if (group.equals(CALENDAR)) {
                groupsToView.addAll(Arrays.asList(Status.FLOATING, Status.OVERDUE,
                                                    Status.TODAY, Status.TOMORROW, Status.FUTURE));
            } else {
                groupsToView.add(group);
            }
        }
        viewTasksWithStatus(removeDuplicateViews(groupsToView));
        logger.info("View changed to " + String.join("|", groupsToView));
    }

}
```
###### \java\seedu\address\ui\UiColor.java
``` java
package seedu.address.ui;

import java.util.Random;


/**
 * Represents a color in RGB format with some utility methods
 * for adjusting color code.
 */
public class UiColor {

    public static final String HEXCODE_FORMAT = "#%s%s%s";
    public static final int HEXCODE_NUM_CHAR = 2;

    public static final int COLOR_RANGE = 256;

    public static final UiColor WHITE = new UiColor(COLOR_RANGE - 1, COLOR_RANGE - 1, COLOR_RANGE - 1);
    public static final UiColor BLACK = new UiColor(0, 0, 0);

    // Constants for darkness calculation
    public static final double DARKNESS_OF_RED = 0.299;
    public static final double DARKNESS_OF_GREEN = 0.587;
    public static final double DARKNESS_OF_BLUE = 0.114;
    public static final double DARKNESS_THRESHOLD = 0.3;

    // A flat ui colors palette
    public static final UiColor[] palette = {
        new UiColor(230, 126, 34), new UiColor(246, 36, 89), new UiColor(155, 89, 182),
        new UiColor(46, 204, 113), new UiColor(26, 188, 156), new UiColor(231, 76, 60),
        new UiColor(68, 108, 179), new UiColor(219, 10, 91), new UiColor(174, 168, 211),
        new UiColor(52, 152, 219), new UiColor(241, 196, 15), new UiColor(102, 51, 153),
        new UiColor(210, 82, 127), new UiColor(51, 110, 123), new UiColor(78, 205, 196),
        new UiColor(52, 73, 94), new UiColor(30, 130, 76)
    };
    public static int currentColorIndex = 0;

    private int red;
    private int green;
    private int blue;

    public UiColor() {
        this.red = this.green = this.blue = 0;
    }

    public UiColor(int red, int green, int blue) {
        this.red = red;
        this.green = green;
        this.blue = blue;
    }

    /**
     * Returns a color from the palette or a random one if the list is exhausted.
     **/
    public static UiColor getRandomColor() {
        if (currentColorIndex >= palette.length) {
            Random random = new Random();
            UiColor color = new UiColor(random.nextInt(COLOR_RANGE),
                    random.nextInt(COLOR_RANGE),
                    random.nextInt(COLOR_RANGE));
            return (color.isDarkColor() ? color : color.mixWith(BLACK));
        } else {
            if (currentColorIndex == 0) {
                // Shuffle color list on first access
                shufflePalette();
            }
            return palette[currentColorIndex++];
        }
    }

    public static void shufflePalette() {
        Random random = new Random();
        for (int i = 0;  i < palette.length;  i++) {
            int color1 = random.nextInt(palette.length);
            int color2 = random.nextInt(palette.length);

            // Swap
            UiColor temp = palette[color1];
            palette[color1] = palette[color2];
            palette[color2] = temp;
        }
    }

    public UiColor mixWith(UiColor other) {
        return new UiColor((this.red + other.red) / 2,
                            (this.green + other.green) / 2,
                            (this.blue + other.blue) / 2);
    }

    public boolean isDarkColor() {
        double darkness = 1 - (DARKNESS_OF_RED * this.red
                                + DARKNESS_OF_GREEN * this.green
                                + DARKNESS_OF_BLUE * this.blue) / (COLOR_RANGE - 1);
        return darkness > DARKNESS_THRESHOLD;
    }

    public String getHexCode(int value) {
        String hex = Integer.toHexString(value);
        // Add zero until enough
        while (hex.length() < HEXCODE_NUM_CHAR) {
            hex = '0' + hex;
        }
        return hex;
    }

    @Override
    public String toString() {
        return String.format(HEXCODE_FORMAT,
                getHexCode(red),
                getHexCode(green),
                getHexCode(blue));
    }
}
```
